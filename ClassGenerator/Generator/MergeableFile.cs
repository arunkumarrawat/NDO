//
// Copyright (C) 2002-2008 HoT - House of Tools Development GmbH 
// (www.netdataobjects.com)
//
// Author: Mirko Matytschak
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License (v3) as published by
// the Free Software Foundation.
//
// If you distribute copies of this program, whether gratis or for 
// a fee, you must pass on to the recipients the same freedoms that 
// you received.
//
// Commercial Licence:
// For those, who want to develop software with help of this program 
// and need to distribute their work with a more restrictive licence, 
// there is a commercial licence available at www.netdataobjects.com.
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

using System;
using System.IO;
using System.Collections.Generic;
using System.Text;

namespace Generator
{
	class MergeableFile
	{
		string fileName;
		string oldFileName;
		bool fileExists = false;
		bool skipHeader;
		bool ignoreSpaces;
		Stream stream = null;


		public MergeableFile( string fileName ) : this(fileName, false)
		{
		}

		public MergeableFile( string fileName, bool skipHeader )
		{
			this.fileName = fileName;
			this.skipHeader = skipHeader;
			string extension = Path.GetExtension(fileName);
			this.oldFileName = Path.ChangeExtension(fileName, extension + ".old");
		}

		public string OldFileName
		{
			get { return oldFileName; }
		}

		public Stream Stream
		{
			get
			{
				if ( this.stream == null )
				{
					fileExists = File.Exists( this.fileName );
					if ( fileExists )
					{
						if ( File.Exists( oldFileName ) )
							File.Delete( oldFileName );
						File.Move( this.fileName, this.oldFileName );
					}
					this.stream = new MemoryStream();
				}
				return this.stream;
			}
		}

		public void Restore()
		{
			if (fileExists)
				File.Move(this.oldFileName, this.fileName);

			fileExists = false;
		}

		void SkipLines(int nLines)
		{
			byte[] arr = ((MemoryStream)this.stream).GetBuffer();
			byte c;
			int i = 0;
			for ( int lc = 0; lc < nLines; lc++ )
			{
				while ( (c = arr[i]) != '\r' )
					i++;
				i++;
				if ( arr[i] == '\n' )
					i++;
			}
			string s = Encoding.Default.GetString(arr, 0, i);
			stream.Position = i;
		}

		void WriteToFile()
		{
			byte[] buffer = new byte[4096];
			MemoryStream ms = (MemoryStream)this.stream;
			FileStream fs = new FileStream(this.fileName, FileMode.Create, FileAccess.Write);
			fs.Write(ms.GetBuffer(), (int)ms.Position, (int)(ms.Length - ms.Position));
			fs.Close();
		}

		public bool Write()
		{
			this.stream.Position = 0L;
			bool hasConflicts = false;

			// Eliminate the header generated by the CodeDOM compiler.
			if ( skipHeader )
				SkipLines(9);

			if ( fileExists )
			{
				hasConflicts = Merge.MergeFiles( this.oldFileName, this.stream, this.fileName );
			}
			else
			{
				WriteToFile();
			}

			return hasConflicts;
		}

		public bool IgnoreSpaces
		{
			get { return ignoreSpaces; }
			set { ignoreSpaces = value; }
		}

	}
}
