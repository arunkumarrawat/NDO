//
// Copyright (c) 2002-2016 Mirko Matytschak 
// (www.netdataobjects.de)
//
// Author: Mirko Matytschak
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated 
// documentation files (the "Software"), to deal in the Software without restriction, including without limitation 
// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the 
// Software, and to permit persons to whom the Software is furnished to do so, subject to the following 
// conditions:

// The above copyright notice and this permission notice shall be included in all copies or substantial portions 
// of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED 
// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
// CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
// DEALINGS IN THE SOFTWARE.


using System;
using System.IO;
using System.Collections.Generic;
using System.Text;

namespace Generator
{
	class MergeableFile
	{
		string fileName;
		string oldFileName;
		bool fileExists = false;
		bool skipHeader;
		bool ignoreSpaces;
		Stream stream = null;


		public MergeableFile( string fileName ) : this(fileName, false)
		{
		}

		public MergeableFile( string fileName, bool skipHeader )
		{
			this.fileName = fileName;
			this.skipHeader = skipHeader;
			string extension = Path.GetExtension(fileName);
			this.oldFileName = Path.ChangeExtension(fileName, extension + ".old");
		}

		public string OldFileName
		{
			get { return oldFileName; }
		}

		public Stream Stream
		{
			get
			{
				if ( this.stream == null )
				{
					fileExists = File.Exists( this.fileName );
					if ( fileExists )
					{
						if ( File.Exists( oldFileName ) )
							File.Delete( oldFileName );
						File.Move( this.fileName, this.oldFileName );
					}
					this.stream = new MemoryStream();
				}
				return this.stream;
			}
		}

		public void Restore()
		{
			if (fileExists)
				File.Move(this.oldFileName, this.fileName);

			fileExists = false;
		}

		void SkipLines(int nLines)
		{
			byte[] arr = ((MemoryStream)this.stream).GetBuffer();
			byte c;
			int i = 0;
			for ( int lc = 0; lc < nLines; lc++ )
			{
				while ( (c = arr[i]) != '\r' )
					i++;
				i++;
				if ( arr[i] == '\n' )
					i++;
			}
			string s = Encoding.Default.GetString(arr, 0, i);
			stream.Position = i;
		}

		void WriteToFile()
		{
			byte[] buffer = new byte[4096];
			MemoryStream ms = (MemoryStream)this.stream;
			FileStream fs = new FileStream(this.fileName, FileMode.Create, FileAccess.Write);
			fs.Write(ms.GetBuffer(), (int)ms.Position, (int)(ms.Length - ms.Position));
			fs.Close();
		}

		public bool Write()
		{
			this.stream.Position = 0L;
			bool hasConflicts = false;

			// Eliminate the header generated by the CodeDOM compiler.
			if ( skipHeader )
				SkipLines(9);

			if ( fileExists )
			{
				hasConflicts = Merge.MergeFiles( this.oldFileName, this.stream, this.fileName );
			}
			else
			{
				WriteToFile();
			}

			return hasConflicts;
		}

		public bool IgnoreSpaces
		{
			get { return ignoreSpaces; }
			set { ignoreSpaces = value; }
		}

	}
}
